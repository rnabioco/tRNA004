---
title: "RNA_mods"
author: "Laura White"
date: "2024-01-14"
output: html_document
---
```{r global options, include = FALSE}
knitr::opts_chunk$set(message=FALSE)
library(tidyverse)
library(colorblindr)
library(ggokabeito)
library(cowplot)
library(ggbeeswarm)
library(patchwork)
library(ggtext)
library(here)
here::i_am("Rmd/RNA_mods.Rmd")
```
We can take our tRNA basecalling error data and ask questions about how well we can detect different RNA modifications in multiple sequence contexts across multiple organisms. This is enabled by (a) abundant LC/MS data about tRNA modifications from Modomics and (b) our ability to pin our basecalling error data onto structure files and line them up with modification info.

Below, bring in the mapping information for budding yeast.
```{r}
read_tsv(here("ref/structural_alignments/modified/sacCer.mods.seq2structure.tsv")) %>%
  rename(Position = seq_pos, mod_nt = struct_nt) %>%
  select(-struct_ref) %>%
  rename(Reference = seq_ref) -> mod_mappings

read_tsv(here("ref/structural_alignments/unmodified/sacCer.seq2structure.tsv")) %>%
  rename(Position = seq_pos) %>%
  select(-struct_ref) %>%
  rename(Reference = seq_ref) -> nomod_mappings

left_join(nomod_mappings, mod_mappings) -> mappings
remove(mod_mappings, nomod_mappings)
```
Then bring in tsv that contains the error frequencies for budding yeast.
```{r}
read_bcerr <- function(x, Sample, ref) {
  df <- readr::read_tsv(x, show_col_types = FALSE)
  
  df <- df %>%
    dplyr::mutate(Sample = Sample)
  
  return(df)
}

# Function to create rolling strings of kmers
create_rolling_string <- function(nt_vec) {
  sapply(seq_along(nt_vec), function(i) {
    if (i < 3 | i > length(nt_vec) - 2) {
      return(NA)
    }
    
    rolling_elems <- c(lag(nt_vec, 2)[i], lag(nt_vec, 1)[i], nt_vec[i], lead(nt_vec, 1)[i], lead(nt_vec, 2)[i])
    
    if (any(is.na(rolling_elems))) {
      return(NA)
    } else {
      return(paste0(rolling_elems, collapse = ""))
    }
  })
}

read_bcerr(here("bcerror/test.bcerr.tsv"), "WT") -> wt

left_join(wt, mappings, by = c("Reference", "Position")) %>%
  select(-N_freq, -Position) %>%
  rename(Position = struct_pos) %>%
  filter(!is.na(Position)) %>% # this removes tRNAs that do not have structural info in the mappings df
  mutate(Position = Position -24) %>%
  group_by(Reference) %>%
  arrange(Position) %>%
  mutate(kmer_context = create_rolling_string(struct_nt)) %>%
  mutate(mod_context = create_rolling_string(mod_nt)) %>%
  filter(!is.na(kmer_context) & !mod_nt %in% c('A', 'C', 'G', 'T', 'U')) %>% # only keep positions with modifications
  filter(Coverage >29) %>% # enforce coverage threshold
  mutate(BCerror = MismatchFreq + InsertionFreq + DeletionFreq) -> mapped 

# how many unique mod sequence contexts? 267 for 27 modifications over almost 3k tRNA sites.
n_distinct(mapped$mod_context)
n_distinct(mapped$mod_nt)
```

We also pull in the database of Modomics codes in order to convert single character codes to short names.
```{r}
read_csv(here("Modomics/modomicscodes.csv")) %>%
  select(Name, `Short Name`, `RNAMods code (2023)`) %>%
  rename(modname = Name, shortname = `Short Name`, mod_nt = `RNAMods code (2023)`) %>%
  group_by(mod_nt) %>%
  arrange(mod_nt, shortname) %>%
  # filter 5'-monophosphate containing duplicate shortnames
  filter(!(startsWith(shortname, "p") & (mod_nt %in% lag(mod_nt) | mod_nt %in% lead(mod_nt)))) -> modomics


left_join(mapped, modomics) -> mapped
```

```{r}
ggplot(mapped, aes(x = shortname, y = MismatchFreq)) +
  geom_jitter(cex = 0.2, alpha = 0.4, size = 0.5, width = 0.25) +  # Jitter plot
  geom_boxplot(width = 0.2, alpha = 0.5, outlier.shape = NA, fill = "#56B4E9") +
  theme_bw() +
  labs(title = "Mismatch frequency at modified nucleotides in budding yeast tRNAs",
       x = "",
       y = "Mismatch frequency") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.3))

```

Do that, but as a plotting function.
```{r}
plot_modification_data <- function(mapped, shortname) {
  # Filter for the specified modification using an explicit environment
  filtered_data <- mapped %>%
    filter(shortname == !!shortname)

  # Retrieve the corresponding mod_nt and long name
  mod_nt_value <- filtered_data$mod_nt[1]
  mod_name_value <- filtered_data$modname[1]

  # MeanQual Plot
  plot_quals <- ggplot(filtered_data, aes(x = mod_context, y = MeanQual)) +
    geom_jitter(alpha = 1, width = .25) +
    geom_boxplot(width = 0.2, alpha = .5, outlier.shape = NA, color = "#009E73") +
    theme_bw() +
    labs(title = paste("Basecalling quality score in different nucleotide contexts,", shortname, "/", mod_nt_value, "/", mod_name_value),
         x = "",
         y = "Mean Qscore") +
    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5, margin = margin(2, 0, 2, 0), size = 10),
          axis.ticks.x = element_blank())
  
    # Insertion Frequency Plot
  plot_insertions <- ggplot(filtered_data, aes(x = mod_context, y = InsertionFreq)) +
    geom_jitter(alpha = 1, width = .25) +
    geom_boxplot(width = 0.2, alpha = .5, outlier.shape = NA, color = "#009E73") +
    theme_bw() +
    labs(title = paste("Insertion frequencies in different nucleotide contexts,", shortname, "/", mod_nt_value, "/", mod_name_value),
         x = "",
         y = "Insertion freq") +
    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5, margin = margin(2, 0, 2, 0), size = 10),
          axis.ticks.x = element_blank())

# Deletion Frequency Plot
  plot_deletions <- ggplot(filtered_data, aes(x = mod_context, y = DeletionFreq)) +
    geom_jitter(alpha = 1, width = .25) +
    geom_boxplot(width = 0.2, alpha = .5, outlier.shape = NA, color = "#009E73") +
    theme_bw() +
    labs(title = paste("Deletion frequencies in different nucleotide contexts,", shortname, "/", mod_nt_value, "/", mod_name_value),
         x = "",
         y = "Deletion freq") +
    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5, margin = margin(2, 0, 2, 0), size = 10),
          axis.ticks.x = element_blank())
  
  # Mismatch Frequency Plot
  plot_mismatch <- ggplot(filtered_data, aes(x = mod_context, y = MismatchFreq)) +
    geom_jitter(alpha = 1, width = .25) +
    geom_boxplot(width = 0.2, alpha = .5, outlier.shape = NA, color = "#009E73") +
    theme_bw() +
    labs(title = paste("Mismatch frequencies in different nucleotide contexts,", shortname, "/", mod_nt_value, "/", mod_name_value),
         x = "",
         y = "Mismatch freq") +
    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5, margin = margin(2, 0, 2, 0), size = 10),
          axis.ticks.x = element_blank())

  # Normalized Nucleotide Frequencies Plot
  normalized_data <- filtered_data %>%
    pivot_longer(cols = c(A_Freq, T_Freq, G_Freq, C_Freq), 
                 names_to = "Nucleotide", 
                 values_to = "Frequency") %>%
    group_by(mod_context) %>%
    mutate(Total_Freq = sum(Frequency, na.rm = TRUE)) %>%
    ungroup() %>%
    mutate(Normalized_Freq = Frequency / Total_Freq)

  # Prepare the plot_normalized without a legend
  plot_normalized <- ggplot(normalized_data, aes(x = mod_context, y = Normalized_Freq, fill = Nucleotide)) +
    geom_bar(stat = "identity", position = "fill") +
    theme_bw() +
    labs(title = paste("Normalized nucleotide frequencies,", shortname, "/", mod_nt_value, "/", mod_name_value),
         x = "5mer nucleotide context",
         y = "Nucleotide freq") +
    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5, margin = margin(2, 0, 2, 0), size = 10),
          axis.ticks.x = element_blank()) +
    scale_fill_manual(values = c("A_Freq" = "#D55E00", "T_Freq" = "#0072B2", "G_Freq" = "#009E73", "C_Freq" = "#F0E442")) +
    theme(legend.position = "none")  # Remove legend from the plot

# Extract the legend as a separate object
  legend <- cowplot::get_legend(plot_normalized + theme(legend.position = "right"))

# Create a blank plot that would be the legend for the top plot, forcing the legend to align with the bottom plot
  blank_plot <- ggplot() + theme_void() + theme(plot.background = element_rect(fill = "transparent", colour = NA))

  # Stack the plots vertically
  plot_stacked <- plot_quals /plot_deletions /plot_insertions / plot_mismatch / plot_normalized

  # Combine the stacked plots with the blank plot and the legend
  plot_combined <- cowplot::plot_grid(
    plot_stacked, 
    cowplot::plot_grid(blank_plot, legend, ncol = 1, rel_heights = c(1, 1)),
    ncol = 2, 
    rel_widths = c(1, 0.2),
    align = 'v'
  )

# Define the name of the output file based on the shortname
  output_filename <- paste0(shortname, ".png")
  
  # Define the output path using the here package
  output_path <- here("modplots", output_filename)

  
  # Save the combined plot to a file
  ggsave(output_path, plot_combined, height = 10, width = 11, units = "in")

  return(plot_combined)
}
```
Iterate through every modification shortname and make plots.
```{r}
# Loop through each value in the shortname column
for (shortname in allshortname$shortname) {
  # Call the plotting function for each shortname
  plot_modification_data(mapped, shortname)
}
```



and/or look at some of this stuff next to each other

```{r}
# Converting data to long format
long_data <- mapped %>%
  pivot_longer(cols = c(MismatchFreq, InsertionFreq, DeletionFreq), 
               names_to = "attribute", 
               values_to = "attribute_value")

# Creating faceted violin plot
ggplot(long_data, aes(x = attribute_value, y = attribute)) +
  geom_violin(trim = FALSE) +
  facet_wrap(~shortname, nrow =4) +
  theme_bw() +
  labs(title = "Basecalling error frequencies at yeast tRNA modifications",
       x = "",
       y = "Frequency")

ggsave(here("modplots/frequencies.png"))

```

