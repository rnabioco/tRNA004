---
title: "TRUB1"
author: "Laura White"
date: "2024-01-17"
output: html_document
---
```{r global options, include = FALSE}
knitr::opts_chunk$set(message=FALSE)
library(tidyverse)
library(colorblindr)

library(ggokabeito)
library(cowplot)
library(stringr)
library(here)
here::i_am("Rmd/TRUB1.Rmd")
```
What does basecalling error look like on human tRNAs when TRUB1 is overexpressed?
Given tsv files generated by `get_bcerror_freqs.py`, examine the overall differences in basecalling error frequencies on different tRNAs between two samples.
```{r}
read_bcerr <- function(x, Sample, ref) {
  df <- readr::read_tsv(x, show_col_types = FALSE)
  
  df <- df %>%
    dplyr::mutate(Sample = Sample)
  
  return(df)
}

read_bcerr(here("bcerror/Trub1doxH295R004_20231207.bcerror.tsv"), "dox") -> dox
read_bcerr(here("bcerror/Trub1untrH295R004_20231207.bcerror.tsv"), "untr") -> untr

bind_rows(dox, untr) %>%
  mutate(Position = (Position - 24)) -> all # begin counting at the first NT of the tRNA.

rm(dox, untr)

```

Okay, so now how do we handle the nuclear tRNAs?
We need to go back to our original dataset and roll up the values for each tRNA by isodecoder family.
Then widen the data as before, with enforced coverage threshold and error difference calculations.


Widen the data to enforce a coverage threshold and calculate bc error differences.
```{r}
all %>%
  separate(Reference, into = c("tRNA", "AA", "Anticodon", "Family", "Species"), sep = "-") %>%
  mutate(
    BCErrorFreq = pmin(BCErrorFreq, 1)  # Ensuring BCerror values are between 0 and 1
  ) %>%
  group_by(tRNA, AA, Anticodon, Position, Sample) %>%
  summarise(
    TotalCoverage = sum(Spanning_Reads),
    WeightedBCerror = sum(pmin(BCErrorFreq, 1) * Spanning_Reads) / sum(Spanning_Reads),  # Revised weighted average calculation
    .groups = "drop"
  ) %>%
  mutate(
    BCErrorFreq = ifelse(TotalCoverage > 0, WeightedBCerror, 0)
  ) %>%
  ungroup() %>%
  unite(Reference, c("tRNA", "AA", "Anticodon"), sep = "-") %>%
  select(Sample, Reference, Position, TotalCoverage, BCErrorFreq) %>%
  pivot_wider(
    names_from = Sample,
    names_sep = "_",
    values_from = c(TotalCoverage, BCErrorFreq)
  ) %>%
  mutate(
    MinCov = pmin(TotalCoverage_untr, TotalCoverage_untr, na.rm = TRUE),
    BCerror_dox = replace(BCErrorFreq_dox, MinCov < 29, 0),
    BCerror_untr = replace(BCErrorFreq_untr, MinCov < 29, 0),
    TRUB1_delta = BCErrorFreq_dox - BCErrorFreq_untr,
  ) -> diffs
  
```

```{r}
read_tsv(here("ref/structural_alignments/unmodified/hsapiens.seq2structure.tsv")) %>%
  mutate(struct_pos = (struct_pos - 24)) %>%
  mutate(Position = (seq_pos - 24)) %>%
  rename(Reference = seq_ref)-> mappings

left_join(diffs, mappings, by = c("Reference", "Position")) %>%
  select(Reference, Position, BCErrorFreq_dox, BCErrorFreq_untr, TRUB1_delta) -> test

plot_basecalling_error(test, "Basecalling error change on human tRNAs upon TRUB1 overexpression")
```

```{r}
plot_basecalling_error <- function(data, title_suffix, include_legend = TRUE) {
  # 99 custom x-axis labels for consensus tRNA secondary structure
  x_labels <- c("0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", 
                "17a", "18", "19", "20", "20a", "20b", "21", "22", "23", "24", "25", "26", "27", "28", "29", "30", 
                "31", "32", "33", "34", "35", "36", "37", "38", "39", "40", "41", "42", "43", "44", "45", "46", "47", "48", 
                "e11", "e12", "e13", "e14", "e15", "e16", "e17", "e1", "e2", "e3", "e4", "e5", 
                "e27", "e26", "e25", "e24", "e23", "e22", "e21", "49", "50", "51", "52", "53", "54", "55", "56", "57", 
                "58", "59", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "70", "71", "72", "73", "C", "C", "A")

  # Filter the dataset
  filtered_data <- data %>%
    filter(!is.na(Position), Position >= 1, Position <= 99) %>%
    group_by(Reference) %>%
    filter(any(TRUB1_delta != 0)) %>%
    ungroup() %>%
    mutate(Reference = fct_rev(as.factor(Reference)))

  # Creating a complete grid of Position for each Reference
  complete_grid <- expand.grid(Position = 1:99, Reference = unique(filtered_data$Reference))

  # Left join with the filtered dataset
  full_data <- complete_grid %>%
    left_join(filtered_data, by = c("Position", "Reference"))

  
  # Define a custom function for conditional fill
  conditional_fill <- function(delta_value) {
    ifelse(is.na(delta_value), NA, ifelse(abs(delta_value) < 0.1, 0, delta_value))
  }

  # Apply conditional fill
  full_data$Conditional_TRUB1 <- sapply(full_data$TRUB1_delta, conditional_fill)

  # plot
  p <- ggplot(full_data, aes(x = Position, y = Reference)) +
  geom_tile(aes(fill = Conditional_TRUB1), color = "white", size = 0.1) +
  scale_fill_gradient2(low = "#0072B2", high = "#D55E00", mid = "white", midpoint = 0, 
                         limits = c(-1, 1), na.value = "#D3D3D3") +
  scale_x_continuous(breaks = 1:99, labels = x_labels) +
    theme_cowplot() +
    labs(fill = "TRUB1 âˆ†",
         title = paste("", title_suffix),
         x = "",
         y = "")

  # Conditional legend settings
  if (include_legend) {
    p <- p + theme(legend.position = c(1, 1),
    legend.justification = c(1, 1),
    legend.box.just = "right",
    legend.margin = margin(0, 0, 0, 0),
    legend.background = element_rect(fill = "transparent", color = NA),
    legend.box.background = element_rect(fill = "transparent", color = NA),
    legend.key = element_rect(fill = "transparent", color = NA),
    legend.title = element_text(size = 10),
    legend.text = element_text(size = 9))}
    else {
  p <- p + theme(legend.position = "none")
  }
  
  p <- p + theme(
  axis.text.y = element_text(angle = 0, hjust = 1, vjust = 0.3, size = 10),
  axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.3, size = 10),
  ) +
  coord_fixed(ratio = 1)
  
  return(p)
  }

     


```
