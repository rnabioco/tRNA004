---
title: "Basecalling error analysis"
author: "Laura White"
date: "2023-12-27"
output: html_document
---
```{r global options, include = FALSE}
knitr::opts_chunk$set(message=FALSE)
library(tidyverse)
library(colorblindr)

library(ggokabeito)
library(cowplot)
library(stringr)
library(here)
here::i_am("Rmd/bcerror.Rmd")
```
Given tsv files generated by `get_bcerror_freqs.py`, examine the overall differences in basecalling error frequencies on different tRNAs between two samples. Let's start with our yeast controls, wild type BY4741 vs. pus4∆, both basecalled with Dorado 0.5.0's _sup_ model for RNA004.
```{r}
read_bcerr <- function(x, Sample, ref) {
  df <- readr::read_tsv(x, show_col_types = FALSE)
  
  df <- df %>%
    dplyr::mutate(Sample = Sample)
  
  return(df)
}

read_bcerr(here("bcerror/WTyeast004_20231111.tsv"), "WT") -> wt
read_bcerr(here("bcerror/Pus4yeast004_20231208.tsv"), "Pus4del") -> pus4
read_bcerr(here("bcerror/Pus2yeast004_20240105.tsv"), "Pus2del") -> pus2
read_bcerr(here("bcerror/Pus1yeast004_20240105.tsv"), "Pus1del") -> pus1

bind_rows(wt, pus4, pus2, pus1) %>%
  mutate(Position = (Position - 24)) %>%
  mutate(BCerror = MismatchFreq + InsertionFreq + DeletionFreq) -> all # begin counting at the first NT of the tRNA.

rm(wt, pus4, pus2, pus1)

```

Widen the data to enforce a coverage threshold and calculate bc error differences.
```{r}
all %>%
  select(Sample, Reference, Position, Coverage, BCerror) %>%
  pivot_wider(
    names_from = Sample,
    names_sep = "_",
    values_from = c(Coverage, BCerror)
  ) %>%
  mutate(
    MinCov = pmin(Coverage_WT, Coverage_Pus4del, Coverage_Pus2del, Coverage_Pus1del, na.rm = TRUE),
    BCerror_WT = replace(BCerror_WT, MinCov < 29, 0),
    BCerror_Pus4del = replace(BCerror_Pus4del, MinCov < 29, 0),
    BCerror_Pus2del = replace(BCerror_Pus2del, MinCov < 29, 0),
    BCerror_Pus1del = replace(BCerror_Pus1del, MinCov < 29, 0),
    Pus4_delta = BCerror_Pus4del - BCerror_WT,
    Pus2_delta = BCerror_Pus2del - BCerror_WT,
    Pus1_delta = BCerror_Pus1del - BCerror_WT
  ) -> diffs
  
```
Data reshaping.
```{r}
# Reshape the data into a long format
long_data <- diffs %>%
  select(Reference, Position, Pus4_delta, Pus2_delta, Pus1_delta) %>%
  pivot_longer(
    cols = c(Pus4_delta, Pus2_delta, Pus1_delta),
    names_to = "Delta_Type",
    values_to = "Delta_Value"
  )
```

Now, can we pull in our tsv containing sequence to structure mappings, join it, and use that to make nicer plots.
```{r}
read_tsv(here("ref/structural_alignments/unmodified/sacCer.seq2structure.tsv")) %>%
  filter(str_starts(seq_ref, "mito"))  %>% 
  mutate(struct_pos = (struct_pos - 24)) %>%
  mutate(Position = (seq_pos - 24)) %>%
  rename(Reference = seq_ref)-> mito_mappings

long_data %>%
  filter(str_starts(Reference, "mito")) -> mito_long_data

left_join(mito_long_data, mito_mappings, by = c("Reference", "Position")) %>%
  select(-seq_pos) %>%
  mutate(Reference = str_replace(Reference, "mito-tRNA-", "")) %>%
  mutate(Ref_Delta = paste(Reference, Delta_Type, sep = "_")) -> test
```

Plotting function for basecalling error given a filtered set of sequences (here, mito tRNAs).
```{r}
plot_basecalling_error <- function(data, delta_type, title_suffix, include_legend = TRUE) {
  # 99 custom x-axis labels for consensus tRNA secondary structure
  x_labels <- c("0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", 
                "17a", "18", "19", "20", "20a", "20b", "21", "22", "23", "24", "25", "26", "27", "28", "29", "30", 
                "31", "32", "33", "34", "35", "36", "37", "38", "39", "40", "41", "42", "43", "44", "45", "46", "47", "48", 
                "e11", "e12", "e13", "e14", "e15", "e16", "e17", "e1", "e2", "e3", "e4", "e5", 
                "e27", "e26", "e25", "e24", "e23", "e22", "e21", "49", "50", "51", "52", "53", "54", "55", "56", "57", 
                "58", "59", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "70", "71", "72", "73", "C", "C", "A")

  # Filter the dataset
  filtered_data <- data %>%
    filter(!is.na(struct_pos), struct_pos >= 1, struct_pos <= 99, Delta_Type == delta_type) %>%
    group_by(Reference) %>%
    filter(any(Delta_Value != 0)) %>%
    ungroup() %>%
    mutate(Reference = fct_rev(as.factor(Reference)))

  # Creating a complete grid of struct_pos for each Reference
  complete_grid <- expand.grid(struct_pos = 1:99, Reference = unique(filtered_data$Reference))

  # Left join with the filtered dataset
  full_data <- complete_grid %>%
    left_join(filtered_data, by = c("struct_pos", "Reference"))

  # Define a custom function for conditional fill
  conditional_fill <- function(delta_value) {
    ifelse(is.na(delta_value), NA, ifelse(abs(delta_value) < 0.1, NA, delta_value))
  }

  # plot
  p <- ggplot(full_data, aes(x = struct_pos, y = Reference)) +
    # First geom_tile for main data
    geom_tile(aes(fill = Delta_Value), color = "white", size = 0.1) +
    # Second geom_tile for Delta_Value < 0.1
    geom_tile(data = subset(full_data, abs(Delta_Value) < 0.1), aes(x = struct_pos, y = Reference), 
              fill = "white", color = "white", size = 0.1) +
    scale_fill_gradient2(low = "#0072B2", high = "#D55E00", mid = "white", midpoint = 0, 
                         limits = c(-1, 1), na.value = "#D3D3D3") +
    scale_x_continuous(breaks = 1:99, labels = x_labels) +
    theme_cowplot() +
    labs(fill = "∆ BC error \n(WT - MT)",
         title = paste("BC error changes", title_suffix),
         x = "",
         y = "")

  # Conditional legend settings
  if (include_legend) {
    p <- p + theme(
      legend.position = c(1, 1),
      legend.justification = c(1, 1),
      legend.box.just = "right",
      legend.margin = margin(0, 0, 0, 0),
      legend.background = element_rect(fill = "transparent", color = NA),
      legend.box.background = element_rect(fill = "transparent", color = NA),
      legend.key = element_rect(fill = "transparent", color = NA),
      legend.title = element_text(size = 10),
      legend.text = element_text(size = 9)
    ) # Removed the guides modification
  } else {
    p <- p + theme(legend.position = "none")
  }

  
  p <- p + theme(
    axis.text.y = element_text(angle = 0, hjust = 1, vjust = 0.3, size = 10),
    axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.3, size = 10),
  ) +
  coord_fixed(ratio = 1)

  return(p)
}

```

```{r}
plot_basecalling_error(test, "Pus1_delta", "on mt-tRNAs upon Pus1 synthase deletion", T) -> p1
plot_basecalling_error(test, "Pus2_delta", "on mt-tRNAs upon Pus2 synthase deletion", T) -> p2
plot_basecalling_error(test, "Pus4_delta", "on mt-tRNAs upon Pus4 synthase deletion", T) -> p4

library(gridExtra)
# Arrange the plots vertically
composite_plot <- grid.arrange(p1, p2, p4, ncol = 1)

# Print or save the composite plot
composite_plot
```
Okay, so now how do we handle the nuclear tRNAs?
We need to go back to our original dataset and roll up the values for each tRNA by isodecoder family.
Then widen the data as before, with enforced coverage threshold and error difference calculations.
```{r}
all %>%
  filter(str_starts(Reference, "nuc")) %>%
  separate(Reference, into = c("Location", "tRNA", "AA", "Anticodon", "Family", "Species"), sep = "-") %>%
  mutate(
    BCerror = pmin(BCerror, 1)  # Ensuring BCerror values are between 0 and 1
  ) %>%
  group_by(Location, tRNA, AA, Anticodon, Family, Position, Sample) %>%
  summarise(
    TotalCoverage = sum(Coverage),
    WeightedBCerror = sum(pmin(BCerror, 1) * Coverage) / sum(Coverage),  # Revised weighted average calculation
    .groups = "drop"
  ) %>%
  mutate(
    BCerror = ifelse(TotalCoverage > 0, WeightedBCerror, 0)
  ) %>%
  ungroup() %>%
  unite(Reference, c("Location", "tRNA", "AA", "Anticodon", "Family"), sep = "-") %>%
  select(Sample, Reference, Position, TotalCoverage, BCerror) %>%
  pivot_wider(
    names_from = Sample,
    names_sep = "_",
    values_from = c(TotalCoverage, BCerror)
  ) %>%
  mutate(
    MinCov = pmin(TotalCoverage_WT, TotalCoverage_Pus4del, TotalCoverage_Pus2del, TotalCoverage_Pus1del, na.rm = TRUE),
    BCerror_WT = replace(BCerror_WT, MinCov < 29, 0),
    BCerror_Pus4del = replace(BCerror_Pus4del, MinCov < 29, 0),
    BCerror_Pus2del = replace(BCerror_Pus2del, MinCov < 29, 0),
    BCerror_Pus1del = replace(BCerror_Pus1del, MinCov < 29, 0),
    Pus4_delta = BCerror_Pus4del - BCerror_WT,
    Pus2_delta = BCerror_Pus2del - BCerror_WT,
    Pus1_delta = BCerror_Pus1del - BCerror_WT
  ) -> diffs
```


Data reshaping.
```{r}
# Reshape the data into a long format
long_data <- diffs %>%
  select(Reference, Position, Pus4_delta, Pus2_delta, Pus1_delta) %>%
  pivot_longer(
    cols = c(Pus4_delta, Pus2_delta, Pus1_delta),
    names_to = "Delta_Type",
    values_to = "Delta_Value"
  )
```


```{r}
# redundant I think.
long_data %>%
  filter(str_starts(Reference, "nuc")) -> nuc_long_data


read_tsv(here("ref/structural_alignments/unmodified/sacCer.seq2structure.tsv")) %>%
  filter(str_starts(seq_ref, "nuc"))  %>% 
  mutate(struct_pos = (struct_pos - 24)) %>%
  mutate(Position = (seq_pos - 24)) %>%
  rename(Reference = seq_ref) %>%
  # remove species from Ref? maybe awkward
  mutate(Reference = sub("-[^-]*$", "", Reference)) -> nuc_mappings

left_join(nuc_long_data, nuc_mappings, by = c("Reference", "Position")) %>%
  select(-seq_pos) %>%
  mutate(Reference = str_replace(Reference, "nuc-tRNA-", "")) %>%
  mutate(Ref_Delta = paste(Reference, Delta_Type, sep = "_")) -> nuc_mapped

plot_basecalling_error(nuc_mapped, "Pus1_delta", "on nuclear-encoded tRNAs upon Pus1 synthase deletion", T) -> p1
plot_basecalling_error(nuc_mapped, "Pus2_delta", "on nuclear-encoded tRNAs upon Pus2 synthase deletion", T) -> p2
plot_basecalling_error(nuc_mapped, "Pus4_delta", "on nuclear-encoded tRNAs upon Pus4 synthase deletion", T) -> p4

composite_plot <- grid.arrange(p1, p2, p4, ncol = 1)

p1
p2
p4
```
Alright. Now: can we aggregate not just by isodecoder, but across all tRNAs for mito & nuclear to do some comparison?
```{r}
# the problem with doing this at this point is they're not lined up yet on the structure, are they?
# shit, this is a problem collapsing the nuclear tRNAs, too.
# the answer has to be to pull the mappings in BEFORE we start collapsing things.
read_tsv(here("ref/structural_alignments/unmodified/sacCer.seq2structure.tsv")) %>%
  mutate(struct_pos = (struct_pos - 24)) %>%
  rename(Position = seq_pos, Reference = seq_ref) %>%
  mutate(Position = (Position - 24)) -> mappings

all %>%
  left_join(., mappings, by = c("Reference", "Position")) %>%
  select(Reference, Coverage, Sample, BCerror, struct_pos) %>%
  rename(Position = struct_pos) %>%
  separate(Reference, into = c("Location", "tRNA", "AA", "Anticodon", "Family", "Species"), sep = "-") %>%
  group_by(Location, Position, Sample) %>%
  summarise(
    TotalCoverage = sum(Coverage),
    WeightedBCerror = sum(pmin(BCerror, 1) * Coverage) / sum(Coverage),  # Revised weighted average calculation
    .groups = "drop"
  ) %>%
  mutate(
    BCerror = ifelse(TotalCoverage > 0, WeightedBCerror, 0)
  ) %>%
  ungroup() %>%
  select(Sample, Location, Position, TotalCoverage, BCerror) %>%
  pivot_wider(
    names_from = Sample,
    names_sep = "_",
    values_from = c(TotalCoverage, BCerror)
  ) %>%
  mutate(
    MinCov = pmin(TotalCoverage_WT, TotalCoverage_Pus4del, TotalCoverage_Pus2del, TotalCoverage_Pus1del, na.rm = TRUE),
    BCerror_WT = replace(BCerror_WT, MinCov < 29, 0),
    BCerror_Pus4del = replace(BCerror_Pus4del, MinCov < 29, 0),
    BCerror_Pus2del = replace(BCerror_Pus2del, MinCov < 29, 0),
    BCerror_Pus1del = replace(BCerror_Pus1del, MinCov < 29, 0),
    Pus4_delta = BCerror_Pus4del - BCerror_WT,
    Pus2_delta = BCerror_Pus2del - BCerror_WT,
    Pus1_delta = BCerror_Pus1del - BCerror_WT
  ) -> diffs
```


Data reshaping.
```{r}
# Reshape the data into a long format
long_data <- diffs %>%
  select(Location, Position, Pus4_delta, Pus2_delta, Pus1_delta) %>%
  filter(Position %in% c(1:96)) %>% # no variable loop
  pivot_longer(
    cols = c(Pus4_delta, Pus2_delta, Pus1_delta),
    names_to = "Delta_Type",
    values_to = "Delta_Value"
  )

  # 99 custom x-axis labels for consensus tRNA secondary structure
  x_labels <- c("0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", 
                "17a", "18", "19", "20", "20a", "20b", "21", "22", "23", "24", "25", "26", "27", "28", "29", "30", 
                "31", "32", "33", "34", "35", "36", "37", "38", "39", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "50", "51", "52", "53", "54", "55", "56", "57", 
                "58", "59", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "70", "71", "72", "73")
  
  # Adjusting the Position values
long_data <- long_data %>%
  mutate(AdjustedPosition = ifelse(Position > 71, Position - 19, Position)) %>%
  filter(Position != 53:71)  # Remove variable loops from tRNA metaplot

# Plotting
ggplot(long_data, aes(y = Location, x = AdjustedPosition)) +
  geom_tile(aes(fill = ifelse(abs(Delta_Value) < 0.05, NA, Delta_Value)), color = "white", size = 0.1) +
  scale_fill_gradient2(low = "#0072B2", high = "#D55E00", mid = "white", midpoint = 0, 
                       limits = c(-.6, .6), na.value = "white") +
  scale_x_continuous(breaks = c(1:77), labels = x_labels) +
  theme_minimal() +
  labs(fill = "∆ BC error \n(WT - MT)",
       y = "",
       x = "") +
  facet_wrap(~Delta_Type, ncol = 1) + 
  theme(
    axis.text.y = element_text(angle = 0, hjust = 1, vjust = 0.3, size = 10),
    axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.3, size = 10),
  ) + coord_fixed(ratio = 1)
```



