---
title: "RPPPMs"
author: "Laura White"
date: "2023-12-23"
output: html_document
---
```{r global options, include = FALSE}
knitr::opts_chunk$set(message=FALSE)
library(tidyverse)
library(colorblindr)
library(cowplot)
library(here)
here::i_am("Rmd/fig1_RPPPMs.Rmd")
```
RPPPM (reads per pore per minute) is a rough metric for evaluating the throughput of Nanopore sequencing libraries that may be run on different platforms, at different points in a flow cell's lifetime (e.g., first run, after several washes & reruns, etc.), or for different lengths of time. It enables an _approximate_ apples to apples comparison between nanopore seqeuncing runs and libraries. However, while RPPPM is a better choice for comparison than raw library read numbers, is subject to confounding factors. Specifically, this metric may become less meaningful when comparing sequencing runs with a short acquisition time (where pore loss over the run is minimal) to longer runs where pore attrition has a higher impact.

To calculate RPPPM, there's some previous data acquisition that goes into this script:
* Count raw reads from the run's live basecalling from `throughput_*.csv`. Or, if desired, rebasecall and calculate this from the fastq files.
* grep the first value of `total_pores` out of the `report_._*.md` file. This is the total number of available pores across all channels identified during the initial MUX scan at the start of the run.

`grep "Pore scan for flow cell" report*.html | head -n1`

The total pores value is also in the `.json` version of this report, but not as directly greppable from the `.html` version. Weirdly, POD5 files do not contain a field that directly tracks this value. It's possible one could back into it with the information in the [RunInfo class]([)https://pod5-file-format.readthedocs.io/en/latest/reference/api/pod5.html#pod5.RunInfo), but I haven't worked out how to do so yet.

Meanwhile, my crude solution is to grab all those manually and dump them into a .csv file, which I pull in here.
```{r}
read_csv(here("RPPPMs.csv")) -> yields

yields$GenusSpecies <- factor(paste(yields$Genus, yields$Species))


```
And then we plot.
```{r}
# Add a new column to the dataframe
yields <- yields %>%
  mutate(GenusSpeciesShort = paste0(substr(Genus, 1, 1), ". ", Species))

# Plotting the data with the new x-axis labels
yields %>%
  ggplot(aes(x = GenusSpeciesShort, y = RPPPM, fill = Chemistry)) +
  geom_bar(stat = "identity", position = position_dodge()) +
  labs(x = "", y = "RPPPM", fill = "chemistry") +
  theme_cowplot() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, face = "italic")) +
  scale_fill_OkabeIto()
```

```{r}

# Calculate the fold increase for each sample
fold_increase_per_sample <- yields %>%
  group_by(GenusSpecies, Sample) %>%
  summarize(
    RPPPM_002 = mean(RPPPM[Chemistry == "RNA002"], na.rm = TRUE),
    RPPPM_004 = mean(RPPPM[Chemistry == "RNA004"], na.rm = TRUE)
  ) %>%
  mutate(fold_increase = RPPPM_004 / RPPPM_002)

# Print the fold increase per sample
print(fold_increase_per_sample)

# Calculate the overall fold increase across the entire dataset
overall_fold_increase <- yields %>%
  group_by(Chemistry) %>%
  summarize(mean_RPPPM = mean(RPPPM, na.rm = TRUE)) %>%
  spread(Chemistry, mean_RPPPM) %>%
  mutate(overall_fold_increase = RNA004 / RNA002)

# Print the overall fold increase
print(overall_fold_increase)

```

