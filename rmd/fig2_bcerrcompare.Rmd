---
title: "BCerr comparisons"
author: "Laura White"
date: "2024-07-01"
output: html_document
---
```{r global options, include = FALSE}
knitr::opts_chunk$set(message=FALSE)
library(tidyverse)
library(cowplot)
library(ggtext)
library(ggokabeito)
library(ggrepel)
library(here)
here::i_am("Rmd/fig2_bcerrcompare.Rmd")
```

Pull in the complete set of bcerror data with Modomics annotations from `generatebcerrorfiles.Rmd`. This is pre-filtered to only contain positions with at least 30 mapped reads.
```{r}
read_tsv(here("bcerror/combinedbcerr.tsv")) -> mapped
```
```{r}
# Define the function to create individual plots for Figure 2A
create_plot <- function(data, nucleotide) {
  data %>%
    filter(struct_nt == nucleotide) %>%
    filter(chemistry == "004" & bcmodel == "sup" & bcversion == "5") %>%
    filter(Position > 0 & Position < 98) %>%
    filter(mod_nt != "N") %>% # exclude Ns
    mutate(mod_nt = ifelse(mod_nt == nucleotide, nucleotide, "mod")) %>%  # Categorize mod or unmodified nt
    mutate(mod_nt = factor(mod_nt, levels = c(nucleotide, "mod"))) %>%  # Set levels for mod_nt (fixes U order plotting)
    ggplot(aes(x = mod_nt, y = BCErrorFreq)) +
      geom_jitter(cex = 0.2, alpha = 0.1, size = 0.5, width = 0.25) +
      geom_boxplot(width = 0.2, alpha = .75, outlier.shape = NA, color = "#009E73") +
      theme_bw() +
      theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 14),
            axis.text.y = element_text(size = 14)) +
      ylim(0, 1) +
      labs(title = "", 
           x = "",
           y = "")
}

# Generate the individual plots for each nucleotide
plot_A <- create_plot(mapped, "A")
plot_C <- create_plot(mapped, "C")
plot_U <- create_plot(mapped, "U")
plot_G <- create_plot(mapped, "G")

# Combine the plots into a grid using cowplot
combined_plot <- plot_grid(plot_A, plot_C, plot_U, plot_G, labels = "", ncol = 4)

# Display the combined plot
print(combined_plot)

calculate_medians <- function(data, nucleotide) {
  data %>%
    filter(chemistry == "004" & bcmodel == "sup" & bcversion == "5") %>%
    filter(Position > 0 & Position < 98) %>%
    mutate(mod_status = ifelse(mod_nt == nucleotide, paste0("unmod_", nucleotide), paste0("mod_", nucleotide))) %>%
    filter(struct_nt == nucleotide | mod_nt == nucleotide) %>%
    group_by(mod_status) %>%
    summarise(
      median_BCErrorFreq = median(BCErrorFreq, na.rm = TRUE),
      median_InsertionFreq = median(InsertionFreq, na.rm = TRUE),
      median_DeletionFreq = median(DeletionFreq, na.rm = TRUE),
      median_MismatchFreq = median(MismatchFreq, na.rm = TRUE),
      .groups = 'drop'  # Drop grouping after summarization
    ) %>%
    mutate(nucleotide = nucleotide)
}

# Related calculations for text associated with Fig2A
# Calculate medians for each nucleotide
medians_A <- calculate_medians(mapped, "A")
medians_C <- calculate_medians(mapped, "C")
medians_U <- calculate_medians(mapped, "U")
medians_G <- calculate_medians(mapped, "G")

# Combine the results into a single table
combined_medians <- bind_rows(medians_A, medians_C, medians_U, medians_G) %>%
  select(nucleotide, mod_status, everything())

# Display the combined table
print(combined_medians)

# Adjust the combined_medians to correctly split mod_status
combined_medians <- combined_medians %>%
  separate(mod_status, into = c("mod_status", "nucleotide"), sep = "_", extra = "drop")


# Reshape the combined table
reshaped <- combined_medians %>%
  pivot_wider(
    names_from = mod_status,
    values_from = c(median_BCErrorFreq, median_InsertionFreq, median_DeletionFreq, median_MismatchFreq),
    names_glue = "{.value}_{mod_status}"
  )

# Calculate the differences between mod and unmod for each nucleotide
differences <- reshaped %>%
  mutate(
    diff_BCErrorFreq = median_BCErrorFreq_mod - median_BCErrorFreq_unmod,
    diff_InsertionFreq = median_InsertionFreq_mod - median_InsertionFreq_unmod,
    diff_DeletionFreq = median_DeletionFreq_mod - median_DeletionFreq_unmod,
    diff_MismatchFreq = median_MismatchFreq_mod - median_MismatchFreq_unmod
  ) %>%
  select(nucleotide, diff_BCErrorFreq, diff_InsertionFreq, diff_DeletionFreq, diff_MismatchFreq)


n_distinct(mapped$mod_context)
n_distinct(mapped$mod_nt) # need to remove Ns from "mods"


# supplemental figure with each kind of bcerror
# plotting function for each nucleobase
plot_mod_nt <- function(mapped, mod_nt_value) {
  mapped %>%
    filter(chemistry == "004" & bcmodel == "sup" & bcversion == "5") %>%
    filter(struct_nt == mod_nt_value) %>%
    filter(Position > 0 & Position < 98) %>%
    mutate(mod_nt = ifelse(mod_nt == mod_nt_value, mod_nt_value, "mod")) %>% # Categorize mod or unmodified nt
    mutate(mod_nt = factor(mod_nt, levels = c(mod_nt_value, "mod"))) %>% # set levels for mod_nt (fixes U order plotting)
    pivot_longer(cols = c(MismatchFreq, InsertionFreq, DeletionFreq), 
                 names_to = "attribute", 
                 values_to = "attribute_value")  %>%
    ggplot(aes(x = mod_nt, y = attribute_value)) +
      geom_jitter(cex = 0.2, alpha = 0.3, size = 0.5, width = 0.25) +
      geom_boxplot(width = 0.2, alpha = .75, outlier.shape = NA, color = "#009E73") +
      facet_wrap(~attribute) +
      theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
      theme_bw() +
      labs(title = "", 
           x = "",
           y = "Frequency")
}
# Generate the individual plots
plot_A <- plot_mod_nt(mapped, "A")
plot_C <- plot_mod_nt(mapped, "C")
plot_U <- plot_mod_nt(mapped, "U")
plot_G <- plot_mod_nt(mapped, "G")

# Combine the plots into a grid with cowplot
combined_plot <- plot_grid(plot_A, plot_C, plot_U, plot_G, labels = "AUTO", ncol = 2)

# Display the combined plot
print(combined_plot)
```

Generate a supplemental table of shortnames and full names for each modification type. 
```{r}
supplemental_table <- mapped %>%
  distinct(shortname, modname)

write.csv(supplemental_table, here("metadata/modnames_table.csv"), row.names = FALSE)
```
For fig 2B, generate the all tRNA mods plots distribution for RNA004 only, with median scores from above 
```{r}
# set an ordering for each shortname from a median frequency
ordered_shortname <- mapped %>%
  filter(chemistry == "004" & bcmodel == "sup" & bcversion == "5") %>%
  filter(!mod_nt %in% c('A', 'C', 'G', 'U', 'N')) %>%
  group_by(shortname) %>%
  filter(Position > 0 & Position < 98) %>%
  summarize(median_deletion = median(DeletionFreq, na.rm = TRUE),
            median_insertion = median(InsertionFreq, na.rm = TRUE),
            median_mismatch = median(MismatchFreq, na.rm = T),
            median_bcerr = median(BCErrorFreq, na.rm = T)
            ) %>%
  arrange(median_bcerr) %>%
  pull(shortname)

# Reorder shortname factor levels based on median bcerr
mapped <- mapped %>%
  filter(shortname != "N") %>%
  mutate(shortname = factor(shortname, levels = ordered_shortname))

# Plot, annotating values for unmodified bases from combined_medians above
mapped %>%
  filter(!mod_nt %in% c('A', 'C', 'G', 'U', '.')) %>%
  filter(shortname != "NA") %>%
  filter(chemistry == "004" & bcmodel == "sup" & bcversion == "5") %>%
  filter(Position >0) %>%
  filter(Position <98) %>%
  ggplot(aes(x = shortname, y = BCErrorFreq)) +
    geom_hline(yintercept = 0.2476489, linetype = "dashed", color = "#009E73") + # unmodified As
    geom_hline(yintercept = 0.1722880, linetype = "dashed", color = "#0072B2") + # unmodified Cs
    geom_hline(yintercept = 0.2363636, linetype = "dashed", color = "#D55E00") + # unmodified Us 
    geom_hline(yintercept = 0.1524008, linetype = "dashed", color = "#F0E442") + # unmodified Gs
#    geom_jitter(cex = 0.2, alpha = 0.4, size = 0.5, width = 0.25) +  # Jitter plot
    geom_boxplot(width = 0.2, alpha = 0.75, fill = "darkgray", outlier.size = 0.5) +
    theme_bw() +
    labs(title = "Basecalling error frequency across unique sequence contexts on tRNA isodecoders",
         x = "",
         y = "BCerror frequency") +
    theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1))

```
Also let's do the same thing for RNA002 only
```{r}
calculate_medians <- function(data, nucleotide) {
  data %>%
    filter(chemistry == "002" & bcmodel == "hac" & bcversion == "1") %>%
    filter(Position > 0 & Position < 98) %>%
    mutate(mod_status = ifelse(mod_nt == nucleotide, paste0("unmod_", nucleotide), paste0("mod_", nucleotide))) %>%
    filter(struct_nt == nucleotide | mod_nt == nucleotide) %>%
    group_by(mod_status) %>%
    summarise(
      median_BCErrorFreq = median(BCErrorFreq, na.rm = TRUE),
      median_InsertionFreq = median(InsertionFreq, na.rm = TRUE),
      median_DeletionFreq = median(DeletionFreq, na.rm = TRUE),
      median_MismatchFreq = median(MismatchFreq, na.rm = TRUE),
      .groups = 'drop'  # Drop grouping after summarization
    ) %>%
    mutate(nucleotide = nucleotide)
}

# Related calculations for text associated with Fig2A
# Calculate medians for each nucleotide
medians_A <- calculate_medians(mapped, "A")
medians_C <- calculate_medians(mapped, "C")
medians_U <- calculate_medians(mapped, "U")
medians_G <- calculate_medians(mapped, "G")

# Combine the results into a single table
combined_medians <- bind_rows(medians_A, medians_C, medians_U, medians_G) %>%
  select(nucleotide, mod_status, everything()) %>%
  separate(mod_status, into = c("mod_status", "nucleotide"), sep = "_", extra = "drop")

# set an ordering for each shortname from a median frequency
ordered_shortname <- mapped %>%
  filter(chemistry == "002" & bcmodel == "hac" & bcversion == "1") %>%
  filter(!mod_nt %in% c('A', 'C', 'G', 'U', 'N')) %>%
  group_by(shortname) %>%
  filter(Position > 0 & Position < 98) %>%
  summarize(median_deletion = median(DeletionFreq, na.rm = TRUE),
            median_insertion = median(InsertionFreq, na.rm = TRUE),
            median_mismatch = median(MismatchFreq, na.rm = T),
            median_bcerr = median(BCErrorFreq, na.rm = T)
            ) %>%
  arrange(median_bcerr) %>%
  pull(shortname)

# Reorder shortname factor levels based on median bcerr
mapped <- mapped %>%
  filter(shortname != "N") %>%
  mutate(shortname = factor(shortname, levels = ordered_shortname))

# Plot, annotating values for unmodified bases from combined_medians above
mapped %>%
  filter(!mod_nt %in% c('A', 'C', 'G', 'U', '.')) %>%
  filter(shortname != 'NA') %>%
  filter(chemistry == "002" & bcmodel == "hac" & bcversion == "1") %>%
  filter(Position >0) %>%
  filter(Position <98) %>%
  ggplot(aes(x = shortname, y = BCErrorFreq)) +
    geom_hline(yintercept = 0.3037975, linetype = "dashed", color = "#009E73") + # unmodified As
    geom_hline(yintercept = 0.1392045, linetype = "dashed", color = "#0072B2") + # unmodified Cs
    geom_hline(yintercept = 0.3333333, linetype = "dashed", color = "#D55E00") + # unmodified Us
    geom_hline(yintercept = 0.2000000, linetype = "dashed", color = "#F0E442") + # unmodified Gs
#    geom_jitter(cex = 0.2, alpha = 0.4, size = 0.5, width = 0.25) +  # Jitter plot
    geom_boxplot(width = 0.2, alpha = 0.75, fill = "darkgray", outlier.size = 0.5) +
    theme_bw() +
    labs(title = "Basecalling error frequency across unique sequence contexts on tRNA isodecoders",
         x = "",
         y = "BCerror frequency") +
    theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1))

```

Then we can start comparing across chemistries (2C).
```{r}
# Set an ordering for each shortname from a median frequency
ordered_shortname <- mapped %>%
  filter(!mod_nt %in% c('A', 'C', 'G', 'U', '.')) %>%
  filter((chemistry == "004" & bcmodel == "sup" & bcversion == "5")| (chemistry == "002" & bcmodel == "hac" & bcversion == "1")) %>% # take only 002hac or 004supv5
  group_by(shortname) %>%
  filter(Position > 0 & Position < 98) %>%
  summarize(median_deletion = median(DeletionFreq, na.rm = TRUE),
            median_insertion = median(InsertionFreq, na.rm = TRUE),
            median_mismatch = median(MismatchFreq, na.rm = TRUE),
            median_bcerr = median(BCErrorFreq, na.rm = TRUE)
            ) %>%
  arrange(median_bcerr) %>%
  pull(shortname)

# Reorder shortname factor levels based on median bcerr
mapped <- mapped %>%
  filter(shortname != "N") %>%
  mutate(shortname = factor(shortname, levels = ordered_shortname))

# Create side-by-side box plots
mapped %>%
  filter(!mod_nt %in% c('A', 'C', 'G', 'U', 'N')) %>%
  filter(bcversion == "5" | bcversion == "1") %>% # take only 002hac or 004supv5
  filter(Position > 0 & Position < 98) %>%
  ggplot(aes(x = shortname, y = BCErrorFreq, fill = chemistry, color = chemistry)) +
    geom_boxplot(position = position_dodge(width = 0.75),  width = 0.5, outlier.shape = NA) +
    scale_fill_manual(values = c("002" = "#E69F00", "004" = "#56B4E9")) +
    scale_color_manual(values = c("002" = "#B07A00", "004" = "#3E80A0")) +
    theme_bw() +
    labs(title = "Basecalling error frequency across unique sequence contexts on tRNA isodecoders",
         x = "",
         y = "BCError frequency") +
    theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1))


# also let's get the differences (002 - 004)
filtered_data <- mapped %>%
  filter((chemistry == "004" & bcmodel == "sup" & bcversion == "5") | 
         (chemistry == "002" & bcmodel == "hac" & bcversion == "1"))

# Calculate the median BCErrorFreq for each shortname within each chemistry
median_data <- filtered_data %>%
  group_by(shortname, chemistry) %>%
  summarize(median_BCErrorFreq = median(BCErrorFreq), .groups = 'drop') %>%
  pivot_wider(names_from = chemistry, values_from = median_BCErrorFreq, names_prefix = "chem_")

# Calculate the difference between the medians for chemistry 004 and 002
median_diff <- median_data %>%
  mutate(diff_medians = chem_004 - chem_002)

# Join with the original data to retain modname
final_data <- median_diff %>%
  left_join(select(filtered_data, shortname, modname), by = "shortname") %>%
  distinct(shortname, .keep_all = TRUE)  # Remove duplicate rows

# View the final dataframe
print(final_data)

ggplot(median_diff, aes(x = shortname, y = diff_medians)) +
  geom_col() + 
  theme_cowplot() +
  labs(title = "",
         x = "",
         y = "∆ BC error (004 - 002)") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1))
# ordered same as plot above vs high to low
```
Generate correlations of mod medians for panels D, E
```{r}
# for 002 vs 004
# Calculate median BCErrorFreq for each shortname and chemistry
median_bcerr <- mapped %>%
  filter(!mod_nt %in% c('A', 'C', 'G', 'U', 'N'), Position > 0, Position < 98) %>%
  group_by(shortname, chemistry, bcmodel, bcversion) %>%
  summarize(median_bcerr = median(BCErrorFreq, na.rm = TRUE)) %>%
  ungroup()

# Separate data for 002 and 004 and merge
median_002 <- median_bcerr %>% filter(chemistry == "002") %>% select(shortname, median_bcerr_002 = median_bcerr)
median_004 <- median_bcerr %>% filter(chemistry == "004" & bcmodel == "sup" & bcversion == "5") %>% select(shortname, median_bcerr_004 = median_bcerr)

merged_data <- merge(median_002, median_004, by = "shortname")

# Calculate Pearson's correlation coefficient
pearson_rho <- cor(merged_data$median_bcerr_002, merged_data$median_bcerr_004, method = "pearson")


# Create scatter plot
ggplot(merged_data, aes(y = median_bcerr_004, x = median_bcerr_002, label = shortname)) +
  geom_point() +
  geom_text_repel() +
  theme_bw() +
  labs(title = "",
       x = "RNA002",
       y = "RNA004") +
  annotate("text", x = -Inf, y = Inf, label = paste("Pearson's ρ:", round(pearson_rho, 2)), 
           hjust = -0.1, vjust = 1.1, size = 5, color = "darkgray") +
  theme_cowplot() +
  theme(aspect.ratio = 1)
  


# for 004 v3 vs v5 sup
# Separate data for 002 and 004 and merge
median_3 <- median_bcerr %>% filter(chemistry == "004" & bcmodel == "sup" & bcversion == "3") %>% select(shortname, median_bcerr_3 = median_bcerr)
median_5 <- median_bcerr %>% filter(chemistry == "004" & bcmodel == "sup" & bcversion == "5") %>% select(shortname, median_bcerr_5 = median_bcerr)

merged_data <- merge(median_3, median_5, by = "shortname")

# Calculate Pearson's correlation coefficient
pearson_rho <- cor(merged_data$median_bcerr_3, merged_data$median_bcerr_5, method = "pearson")

ggplot(merged_data, aes(y = median_bcerr_5, x = median_bcerr_3, label = shortname)) +
  geom_point() +
  geom_text_repel() +
  theme_bw() +
  labs(title = "",
       x = "SUP version 3",
       y = "SUP version 5") +
  annotate("text", x = -Inf, y = Inf, label = paste("Pearson's ρ:", round(pearson_rho, 2)), 
           hjust = -0.1, vjust = 1.1, size = 5, color = "darkgray") +
  theme_cowplot() +
  theme(aspect.ratio = 1)
```
Compare contexts with no additional modifications vs. ones with additional mods in the 5mer for pseudouridine, panel G
```{r}
# Function to count non-AGCU characters in mod_context strings
count_non_agcu_chars <- function(mod_context) {
  # Define the allowed characters
  allowed_chars <- c("A", "G", "C", "U")
  
  # Extract the surrounding characters
  surrounding_chars <- c(substr(mod_context, 1, 1), substr(mod_context, 2, 2), substr(mod_context, 4, 4), substr(mod_context, 5, 5))
  
  # Count the number of non-AGCU characters
  non_agcu_count <- sum(!surrounding_chars %in% allowed_chars)
  
  return(non_agcu_count)
}

mapped <- mapped %>%
  mutate(NonAGCUCount = sapply(mod_context, count_non_agcu_chars))

table(mapped$NonAGCUCount)

# Function to plot modification data
plot_modification_data <- function(mapped, shortname) {
  # Filter for the specified modification
  filtered_data <- mapped %>%
    filter(shortname == !!shortname)
  
  # Add the NonAGCUCount column
  filtered_data <- filtered_data %>%
    mutate(NonAGCUCount = sapply(mod_context, count_non_agcu_chars))
  
  # Retrieve the corresponding mod_nt and long name
  mod_nt_value <- filtered_data$mod_nt[1]
  mod_name_value <- filtered_data$modname[1]
  
  # Plot for each value of NonAGCUCount in the sup v5 data
  plot_bcerror <- filtered_data %>%
    filter(chemistry == "004" & bcmodel == "sup" & bcversion == "5") %>%
    ggplot(., aes(x = factor(NonAGCUCount), y = BCErrorFreq, fill=factor(NonAGCUCount))) +
    geom_violin(alpha = .5) +
    geom_boxplot(width = 0.2, alpha = .5, outlier.shape = NA) +
    theme_cowplot() +
    labs(title = paste("BCerror per tRNA isodecoder,", shortname, "/", mod_nt_value, "/", mod_name_value),
         x = "Number of additional modifications in 5mer",
         y = "BCerror",
         legend = "") +
    theme(axis.text.x = element_text(angle = 0, hjust = 0.5, vjust = 0.5, margin = margin(2, 0, 2, 0), size = 10),
          axis.ticks.x = element_blank()) +
    scale_fill_okabe_ito(order = c(8,2,6))
  
  # Define the name of the output file based on the shortname
  output_filename <- paste0(shortname, "_non_agcu_count.png")
  
  # Define the output path using the here package
  output_path <- here("modplots", output_filename)
  
  # Save the plot to a file
  ggsave(output_path, plot_bcerror, height = 4, width = 4, units = "in")
  
  return(plot_bcerror)
}

# Example usage
plot_modification_data(mapped, "Y")

```
For panel H, plot the correlation across individual pseudoU 5mers between RNA002 and 004.
```{r}

mapped %>%
  filter(shortname == "Y") %>%
  filter((chemistry == "004" & bcmodel == "sup" & bcversion == "5")| (chemistry == "002" & bcmodel == "hac" & bcversion == "1")) %>% # take only 002hac or 004supv5
  select(Reference, Position, MismatchFreq, InsertionFreq, DeletionFreq, BCErrorFreq, MeanQual, species, mod_nt, struct_nt, mod_context, chemistry) %>%
  mutate(chemistry = factor(chemistry)) -> pseudou

# Calculate the median BCErrorFreq for each mod_context and chemistry
aggregated_data <- pseudou %>%
  group_by(mod_context, chemistry) %>%
  summarise(median_BCErrorFreq = median(BCErrorFreq, na.rm = TRUE)) %>%
  ungroup()

# Reshape the data from long to wide format
wide_data <- aggregated_data %>%
  pivot_wider(names_from = chemistry, values_from = median_BCErrorFreq, names_prefix = "median_BCErrorFreq_")

# Add the non-AGCU count column
wide_data <- wide_data %>%
  mutate(non_agcu_count = sapply(mod_context, count_non_agcu_chars))

# Add the non-AGCU count column
wide_data <- wide_data %>%
  mutate(non_agcu_count = sapply(mod_context, count_non_agcu_chars))

# Calculate the axis limits
axis_limits <- range(c(wide_data$median_BCErrorFreq_002, wide_data$median_BCErrorFreq_004), na.rm = TRUE)

# Calculate Pearson correlation coefficient
correlation_coefficient <- cor(wide_data$median_BCErrorFreq_002, wide_data$median_BCErrorFreq_004, use = "complete.obs")

# Plot the correlation with the same axis limits for X and Y and square plot area
plot_correlation <- function(data, corr_coeff) {
  ggplot(data, aes(x = median_BCErrorFreq_002, y = median_BCErrorFreq_004, color = as.factor(non_agcu_count))) +
    geom_text_repel(aes(label = mod_context), size = 3, max.overlaps = Inf) +  # Increase max.overlaps to Inf
    theme_cowplot() +
    labs(title = "",
         x = "Median BCError, RNA002",
         y = "Median BCError, RNA004",
         color = "Additional modifications in 5mer") +
    xlim(axis_limits) +
    ylim(axis_limits) +
    coord_fixed(ratio = 1) +  # Ensure the plot area is square
    annotate("text", x = min(axis_limits), y = max(axis_limits), 
             label = paste("Pearson's ρ:", round(corr_coeff, 2)), 
             hjust = 0, vjust = 1, size = 5) +
    theme(axis.text = element_text(size = 12)) + # Increase axis tick label size
    scale_color_okabe_ito(order = c(8,2,6))
}


# Create the plot
correlation_plot <- plot_correlation(wide_data, correlation_coefficient)
print(correlation_plot)
```

Plotting function for individual modification profiling.
```{r}
plot_modification_data <- function(mapped, shortname) {
  # Filter for the specified modification using an explicit environment
  filtered_data <- mapped %>%
    filter(shortname == !!shortname)

  # Retrieve the corresponding mod_nt and long name
  mod_nt_value <- filtered_data$mod_nt[1]
  mod_name_value <- filtered_data$modname[1]

  # MeanQual Plot
  plot_quals <- ggplot(filtered_data, aes(x = mod_context, y = MeanQual)) +
    geom_jitter(alpha = .5, width = .25) +
    geom_boxplot(width = 0.2, alpha = .5, outlier.shape = NA, color = "#009E73") +
    theme_bw() +
    labs(title = paste("Mean basecalling quality score per tRNA isodecoder,", shortname, "/", mod_nt_value, "/", mod_name_value),
         x = "",
         y = "Mean Qscore") +
    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5, margin = margin(2, 0, 2, 0), size = 10),
          axis.ticks.x = element_blank())
  
    # Insertion Frequency Plot
  plot_insertions <- ggplot(filtered_data, aes(x = mod_context, y = InsertionFreq)) +
    geom_jitter(alpha = .5, width = .25) +
    geom_boxplot(width = 0.2, alpha = .5, outlier.shape = NA, color = "#009E73") +
    theme_bw() +
    labs(title = paste("Mean insertion frequencies per tRNA isodecoder,", shortname, "/", mod_nt_value, "/", mod_name_value),
         x = "",
         y = "Insertion freq") +
    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5, margin = margin(2, 0, 2, 0), size = 10),
          axis.ticks.x = element_blank())

# Deletion Frequency Plot
  plot_deletions <- ggplot(filtered_data, aes(x = mod_context, y = DeletionFreq)) +
    geom_jitter(alpha = .5, width = .25) +
    geom_boxplot(width = 0.2, alpha = .5, outlier.shape = NA, color = "#009E73") +
    theme_bw() +
    labs(title = paste("Mean deletion frequencies per tRNA isodecoder,", shortname, "/", mod_nt_value, "/", mod_name_value),
         x = "5mer nucleotide context",
         y = "Deletion freq") +
    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5, margin = margin(2, 0, 2, 0), size = 10),
          axis.ticks.x = element_blank())
  
  # Mismatch Frequency Plot
  plot_mismatch <- ggplot(filtered_data, aes(x = mod_context, y = MismatchFreq)) +
    geom_jitter(alpha = .5, width = .25) +
    geom_boxplot(width = 0.2, alpha = .5, outlier.shape = NA, color = "#009E73") +
    theme_bw() +
    labs(title = paste("Mean mismatch frequencies per tRNA isodecoder,", shortname, "/", mod_nt_value, "/", mod_name_value),
         x = "",
         y = "Mismatch freq") +
    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5, margin = margin(2, 0, 2, 0), size = 10),
          axis.ticks.x = element_blank())

  # Normalized Nucleotide Frequencies Plot
  normalized_data <- filtered_data %>%
    pivot_longer(cols = c(A_Freq, T_Freq, G_Freq, C_Freq), 
                 names_to = "Nucleotide", 
                 values_to = "Frequency") %>%
    group_by(mod_context) %>%
    mutate(Total_Freq = sum(Frequency, na.rm = TRUE)) %>%
    ungroup() %>%
    mutate(Normalized_Freq = Frequency / Total_Freq)

  # Prepare the plot_normalized without a legend
  plot_normalized <- ggplot(normalized_data, aes(x = mod_context, y = Normalized_Freq, fill = Nucleotide)) +
    geom_bar(stat = "identity", position = "fill") +
    theme_bw() +
    labs(title = paste("Aggregate nucleotide frequencies across all mapped reads, ", shortname, "/", mod_nt_value, "/", mod_name_value),
         x = "5mer nucleotide context", y = "Nucleotide freq") +
    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5, margin = margin(2, 0, 2, 0), size = 10),
          axis.ticks.x = element_blank()) +
    scale_fill_manual(values = c("T_Freq" = "#D55E00", "C_Freq" = "#0072B2", "A_Freq" = "#009E73", "G_Freq" = "#F0E442"))

  # Extract the legend as a separate object from plot_normalized
  legend <- cowplot::get_legend(plot_normalized)

  # Create a combined plot without the legend for plot_normalized
  plot_normalized_no_legend <- plot_normalized + theme(legend.position = "none")

  # Stack the plots vertically
  plot_stacked <- cowplot::plot_grid(
    plot_quals, plot_mismatch, plot_normalized_no_legend, plot_deletions, plot_insertions,
    ncol = 1, align = "v"
  )

  # Create a blank ggplot for spacing
  blank_plot <- ggplot() + theme_void()

  # Combine the stacked plots with the blank plot and the legend
  plot_combined <- cowplot::plot_grid(
    plot_stacked, blank_plot, legend,
    ncol = 3, 
    rel_widths = c(1, 0.1, 0.2), # Adjust these values as needed for proper alignment
    align = 'hv'
  )
  
# Define the name of the output file based on the shortname
  output_filename <- paste0(shortname, ".png")
  
  # Define the output path using the here package
  output_path <- here("modplots", output_filename)

  
  # Save the combined plot to a file
  ggsave(output_path, plot_combined, height = 10, width = 21, units = "in")

  return(plot_combined)
}
```
Can use the above to iterate through every modification shortname and make plots.
```{r}
mapped %>%
  filter(chemistry == "004" & bcmodel == "sup" & bcversion == "5" & shortname == "Y") %>%
    pivot_longer(cols = c(A_Freq, T_Freq, G_Freq, C_Freq), 
                 names_to = "Nucleotide", 
                 values_to = "Frequency") %>%
    group_by(NonAGCUCount) %>%
    mutate(Total_Freq = sum(Frequency, na.rm = TRUE)) %>%
    ungroup() %>%
    mutate(Normalized_Freq = Frequency / Total_Freq) -> normalized_pseu

ggplot(normalized_pseu, aes(x = NonAGCUCount, y = Normalized_Freq, fill = Nucleotide)) +
    geom_bar(stat = "identity", position = "fill") +
    theme_bw() +
    labs(title = "",
         x = "5mer nucleotide context", y = "Nucleotide freq") +
    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5, margin = margin(2, 0, 2, 0), size = 10),
          axis.ticks.x = element_blank()) +
    scale_fill_manual(values = c("T_Freq" = "#D55E00", "C_Freq" = "#0072B2", "A_Freq" = "#009E73", "G_Freq" = "#F0E442")) +
    theme_cowplot()

```
I'd like to have the same type of figure as above, but instead plotted for RNA002 vs RNA004 miscalling at known pseudouridines.
```{r}
# Check RNA002 condition
filtered_data_RNA002 <- mapped %>%
  filter(chemistry == "002" & bcmodel == "hac" & bcversion == "1" & shortname == "Y")

# Check RNA004 condition
filtered_data_RNA004 <- mapped %>%
  filter(chemistry == "004" & bcmodel == "sup" & bcversion == "5" & shortname == "Y")

# Check the number of entries for each
print(nrow(filtered_data_RNA002))
print(nrow(filtered_data_RNA004))


# If both conditions have data, combine them
if (nrow(filtered_data_RNA002) > 0 & nrow(filtered_data_RNA004) > 0) {
  filtered_data <- bind_rows(filtered_data_RNA002, filtered_data_RNA004)
} else {
  stop("No data found for one or both conditions.")
}

filtered_data %>% mutate(NonAGCUCount = sapply(mod_context, count_non_agcu_chars)) -> filtered_data

# Normalize frequencies
normalized_pseu <- filtered_data %>%
  pivot_longer(cols = c(A_Freq, T_Freq, G_Freq, C_Freq), 
               names_to = "Nucleotide", 
               values_to = "Frequency") %>%
  group_by(NonAGCUCount) %>%
  mutate(Total_Freq = sum(Frequency, na.rm = TRUE)) %>%
  ungroup() %>%
  mutate(Normalized_Freq = Frequency / Total_Freq)

# Plot the data
ggplot(normalized_pseu, aes(x = NonAGCUCount, y = Normalized_Freq, fill = Nucleotide)) +
  geom_bar(stat = "identity", position = "fill") +
  theme_bw() +
  labs(title = "",
       x = "5mer nucleotide context", y = "Nucleotide freq") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5, margin = margin(2, 0, 2, 0), size = 10),
        axis.ticks.x = element_blank()) +
  scale_fill_manual(values = c("T_Freq" = "#D55E00", "C_Freq" = "#0072B2", "A_Freq" = "#009E73", "G_Freq" = "#F0E442")) +
  theme_cowplot() +
  facet_wrap(~chemistry, ncol = 1)

# Normalize frequencies for each nucleotide and calculate the proportion for C_Freq
normalized_c_freq <- filtered_data %>%
  pivot_longer(cols = c(A_Freq, T_Freq, G_Freq, C_Freq), 
               names_to = "Nucleotide", 
               values_to = "Frequency") %>%
  group_by(chemistry, NonAGCUCount) %>%
  mutate(Total_Freq = sum(Frequency, na.rm = TRUE)) %>%
  filter(Nucleotide == "T_Freq") %>%
  summarize(T_Frequency = sum(Frequency, na.rm = TRUE),
            Total_Frequency = first(Total_Freq),
            Proportion_T_Frequency = T_Frequency / Total_Frequency,
            .groups = 'drop') %>%
  select(chemistry, NonAGCUCount, Proportion_T_Frequency) %>%
  arrange(chemistry, NonAGCUCount)

# Print out the table
print(normalized_c_freq)
```
Let's take a look at the changes in bcerror at only pseudouridine sites for v3 vs v5 sup basecalling.
```{r}

mapped %>%
  filter(shortname == "Y") %>%
  filter((chemistry == "004" & bcmodel == "sup" & bcversion == "5")| (chemistry == "004" & bcmodel == "sup" & bcversion == "3")) %>%
  select(Reference, Position, MismatchFreq, InsertionFreq, DeletionFreq, BCErrorFreq, MeanQual, species, mod_nt, struct_nt, mod_context, chemistry, bcversion) %>%
  mutate(bcversion = factor(bcversion)) -> pseudou

# Calculate the mean BCErrorFreq for each mod_context and chemistry
aggregated_data <- pseudou %>%
  group_by(mod_context, bcversion) %>%
  summarise(mean_BCErrorFreq = mean(BCErrorFreq, na.rm = TRUE)) %>%
  ungroup()

# Reshape the data from long to wide format
wide_data <- aggregated_data %>%
  pivot_wider(names_from = bcversion, values_from = mean_BCErrorFreq, names_prefix = "mean_BCErrorFreq_")

# Add the non-AGCU count column
wide_data <- wide_data %>%
  mutate(non_agcu_count = sapply(mod_context, count_non_agcu_chars))

# Add the non-AGCU count column
wide_data <- wide_data %>%
  mutate(non_agcu_count = sapply(mod_context, count_non_agcu_chars))

# Calculate the axis limits
axis_limits <- range(c(wide_data$mean_BCErrorFreq_3, wide_data$mean_BCErrorFreq_5), na.rm = TRUE)

# Calculate Pearson correlation coefficient
correlation_coefficient <- cor(wide_data$mean_BCErrorFreq_3, wide_data$mean_BCErrorFreq_5, use = "complete.obs")

# Plot the correlation with the same axis limits for X and Y and square plot area
plot_correlation <- function(data, corr_coeff) {
  ggplot(data, aes(x = mean_BCErrorFreq_3, y = mean_BCErrorFreq_5, color = as.factor(non_agcu_count))) +
    geom_text_repel(aes(label = mod_context), size = 3, max.overlaps = Inf) +  # Increase max.overlaps to Inf
    theme_cowplot() +
    labs(title = "",
         x = "Mean BCError, v3",
         y = "Mean BCError, v5",
         color = "Additional modifications in 5mer") +
    xlim(axis_limits) +
    ylim(axis_limits) +
    coord_fixed(ratio = 1) +  # Ensure the plot area is square
    annotate("text", x = min(axis_limits), y = max(axis_limits), 
             label = paste("Pearson's ρ:", round(corr_coeff, 2)), 
             hjust = 0, vjust = 1, size = 5) +
    theme(axis.text = element_text(size = 12)) + # Increase axis tick label size
    scale_color_okabe_ito(order = c(8,2,6))
}


# Create the plot
correlation_plot <- plot_correlation(wide_data, correlation_coefficient)
print(correlation_plot)
```
I'd like to have the same type of figure as above, but instead plotted for RNA002 vs RNA004 miscalling at known pseudouridines.
```{r}
# look instead at all errors individually
normalized_freq <- filtered_data %>%
  #filter(species == "ecoli" & Position == "78") %>%
  pivot_longer(cols = c(InsertionFreq, DeletionFreq, MismatchFreq, BCErrorFreq), 
               names_to = "Error", 
               values_to = "Frequency") %>%
  group_by(bcversion, NonAGCUCount, Error) %>%
  summarize(mean_frequency = mean(Frequency, na.rm = TRUE), 
            sd_frequency = sd(Frequency, na.rm = TRUE), 
            n = n(), 
            se_frequency = sd_frequency / sqrt(n), 
            .groups = 'drop')

# View the summarized table
print(normalized_freq)

# Convert NonAGCUCount and bcversion to factors
normalized_freq <- normalized_freq %>%
  mutate(
    NonAGCUCount = as.factor(NonAGCUCount),
    bcversion = as.factor(bcversion)
  )

# Plotting the summarized data
normalized_freq %>%
  ggplot(aes(x = bcversion, y = mean_frequency, fill = bcversion)) +
  geom_bar(stat = "identity", position = position_dodge(width = 0.8), width = 0.7) +
  geom_errorbar(aes(ymin = mean_frequency - se_frequency, ymax = mean_frequency + se_frequency),
                width = 0.2, position = position_dodge(width = 0.8)) +
  facet_grid(NonAGCUCount ~ Error, scales = "fixed") +
  scale_fill_manual(values = c("3" = "#56B4E9", "5" = "#0072B2")) +
  theme_minimal() +
  labs(
    title = "BCError Frequencies at pseudoU",
    x = "BC Version",
    y = "Mean Frequency",
    fill = "BC Version"
  ) +
  theme(
    legend.position = "right",
    legend.title = element_blank(),
    legend.direction = "vertical",
    axis.text.x = element_text(angle = 45, hjust = 1)
  )

```


